using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Bindables;

public abstract class PropertyGeneratorBase : IIncrementalGenerator
{
	protected abstract string AttributeName { get; }
	protected abstract string PlatformNamespace { get; }
	protected abstract string AttributeTypeName { get; }
	protected abstract string AttributeSourceText { get; }

	protected abstract string DependencyPropertyName { get; }
	protected abstract string DependencyPropertyKeyName { get; }

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(i => i.AddSource($"{AttributeName}.g.cs", AttributeSourceText.Trim()));

		IncrementalValuesProvider<ClassDeclarationSyntax?> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (x, _) => IsSyntaxTargetForGeneration(x),
				transform: (x, _) => GetSemanticTargetForGeneration(x))
			.Where(static x => x is not null);

		context.RegisterSourceOutput(
			context.CompilationProvider.Combine(classDeclarations.Collect()),
			(compilation, source) => Execute(source.Left, source.Right, compilation));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
	{
		return node is FieldDeclarationSyntax { AttributeLists.Count: > 0 };
	}

	private ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		FieldDeclarationSyntax fieldSyntax = (FieldDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeList in fieldSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeList.Attributes)
			{
				if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				{
					continue;
				}

				INamedTypeSymbol attributeContainingType = attributeSymbol.ContainingType;
				string fullName = attributeContainingType.ToDisplayString();

				if (fullName == AttributeTypeName)
				{
					return fieldSyntax.Parent as ClassDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private void Execute(
		Compilation compilation,
		ImmutableArray<ClassDeclarationSyntax?> classes,
		SourceProductionContext context)
	{
		INamedTypeSymbol? attributeSymbol = compilation.GetTypeByMetadataName(AttributeTypeName);

		if (attributeSymbol == null)
		{
			return;
		}

		foreach (ClassDeclarationSyntax? @class in classes.Distinct())
		{
			if (context.CancellationToken.IsCancellationRequested)
			{
				return;
			}

			if (@class == null)
			{
				continue;
			}

			SemanticModel semanticModel = compilation.GetSemanticModel(@class.SyntaxTree);

			if (ModelExtensions.GetDeclaredSymbol(semanticModel, @class) is not INamedTypeSymbol classSymbol)
			{
				continue;
			}

			ImmutableArray<ISymbol> classMembers = classSymbol.GetMembers();
			List<IFieldSymbol> fields = new();

			foreach (ISymbol member in classMembers)
			{
				if (member is not IFieldSymbol fieldSymbol)
				{
					continue;
				}

				if (!fieldSymbol.GetAttributes().Any(x => x.AttributeClass?.ToDisplayString() == AttributeTypeName))
				{
					continue;
				}

				if (Check(context, classSymbol, fieldSymbol, attributeSymbol) == CheckResult.Valid)
				{
					fields.Add(fieldSymbol);
				}
			}

			if (!fields.Any())
			{
				continue;
			}

			string? classSource = ProcessClass(classSymbol, fields, attributeSymbol);

			if (string.IsNullOrEmpty(classSource))
			{
				continue;
			}

			context.AddSource($"{classSymbol}_Bindables_{AttributeName}.g.cs", classSource!);
		}
	}
	
	private string? ProcessClass(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields, ISymbol attributeSymbol)
	{
		if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default))
		{
			//TODO: Issue a diagnostic that it must be top level.
			return null;
		}

		INamespaceSymbol @namespace = classSymbol.ContainingNamespace;

		CodeBuilder builder = new();

		builder.AppendLine("// Generated by Bindables");
		builder.AppendLine($"using {PlatformNamespace};");
		builder.AppendLine();
		builder.AppendLine("#nullable enable");
		builder.AppendLine();

		if (!@namespace.IsGlobalNamespace)
		{
			builder.AppendLine($"namespace {@namespace}");
			builder.OpenScope();
		}

		builder.AppendLine($"public partial class {classSymbol.Name}");
		builder.OpenScope();

		List<string> initializationLines = new();

		foreach (IFieldSymbol field in fields)
		{
			ProcessField(builder, classSymbol, field, attributeSymbol, initializationLines);
		}

		builder.AppendLine($"static {classSymbol.Name}()");
		builder.OpenScope();

		foreach (string line in initializationLines)
		{
			builder.AppendLine(line);
		}

		builder.CloseScope();
		builder.CloseScope();

		if (!@namespace.IsGlobalNamespace)
		{
			builder.CloseScope();
		}

		return builder.ToString();
	}

	private void ProcessField(
		CodeBuilder builder,
		INamedTypeSymbol classSymbol,
		IFieldSymbol field,
		ISymbol attributeSymbol,
		List<string> initializationLines)
	{
		ITypeSymbol fieldType = field.Type;

		bool isDependencyProperty = fieldType.Name == DependencyPropertyName;
		bool isDependencyPropertyKey = fieldType.Name == DependencyPropertyKeyName;

		if (isDependencyProperty)
		{
			ProcessDependencyProperty(builder, classSymbol, field, attributeSymbol, initializationLines);
		}
		else if (isDependencyPropertyKey)
		{
			ProcessDependencyPropertyKey(builder, classSymbol, field, attributeSymbol, initializationLines);
		}
		else
		{
			// TODO: Internal error.
		}
	}

	protected abstract CheckResult Check(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol,
		IFieldSymbol fieldSymbol,
		INamedTypeSymbol attributeSymbol);

	protected abstract void ProcessDependencyProperty(
		CodeBuilder builder,
		INamedTypeSymbol classSymbol,
		IFieldSymbol field,
		ISymbol attributeSymbol,
		List<string> initializationLines);

	protected abstract void ProcessDependencyPropertyKey(
		CodeBuilder builder,
		INamedTypeSymbol classSymbol,
		IFieldSymbol field,
		ISymbol attributeSymbol,
		List<string> initializationLines);

	protected CheckResult CheckThatClassHasBaseType(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol,
		string expectedBaseType,
		DiagnosticDescriptor diagnosticDescriptor)
	{
		if (!InheritsFrom(classSymbol, expectedBaseType))
		{
			Diagnostic diagnostic = Diagnostic.Create(
				diagnosticDescriptor,
				classSymbol.Locations.FirstOrDefault() ?? Location.None,
				classSymbol.Name);

			context.ReportDiagnostic(diagnostic);
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;

		bool InheritsFrom(INamedTypeSymbol? symbol, string baseTypeName)
		{
			while (symbol != null)
			{
				if (symbol.ToDisplayString() == baseTypeName)
				{
					return true;
				}

				symbol = symbol.BaseType;
			}

			return false;
		}
	}

	protected CheckResult CheckThatStaticConstructorDoesNotExist(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol)
	{
		if (classSymbol.Constructors.Any(x => x.IsStatic && !x.IsImplicitlyDeclared))
		{
			Diagnostic diagnostic = Diagnostic.Create(
				Diagnostics.ClassShouldNotHaveStaticConstructor,
				classSymbol.Locations.FirstOrDefault() ?? Location.None,
				classSymbol.Name);

			context.ReportDiagnostic(diagnostic);
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;
	}

	protected CheckResult CheckThatClassIsPartial(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol)
	{
		IEnumerable<ClassDeclarationSyntax> classSyntaxes = classSymbol.DeclaringSyntaxReferences
			.Select(x => x.GetSyntax())
			.OfType<ClassDeclarationSyntax>();
		
		if (classSyntaxes.Any(x => x.Modifiers.All(y => !y.IsKind(SyntaxKind.PartialKeyword))))
		{
			Diagnostic diagnostic = Diagnostic.Create(
				Diagnostics.ClassShouldBePartial,
				classSymbol.Locations.FirstOrDefault() ?? Location.None,
				classSymbol.Name);

			context.ReportDiagnostic(diagnostic);
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;
	}

	protected CheckResult CheckFieldTypeAndName(
		SourceProductionContext context,
		IFieldSymbol symbol,
		params (string FieldType, string FieldNameSuffix, DiagnosticDescriptor SuffixDiagnostic)[] conditions)
	{
		string typeFullName = symbol.Type.ToDisplayString();
		string fieldName = symbol.Name;

		var matchedCondition = conditions.FirstOrDefault(x => typeFullName == x.FieldType);

		if (matchedCondition == default)
		{
			Diagnostic diagnostic = Diagnostic.Create(
				Diagnostics.IncorrectFieldType,
				symbol.Locations.FirstOrDefault() ?? Location.None,
				symbol.Name,
				matchedCondition.FieldType);

			context.ReportDiagnostic(diagnostic);
			return CheckResult.Invalid;
		}

		if (!fieldName.EndsWith(matchedCondition.FieldNameSuffix))
		{
			Diagnostic diagnostic = Diagnostic.Create(
				matchedCondition.SuffixDiagnostic,
				symbol.Locations.FirstOrDefault() ?? Location.None,
				symbol.Name);

			context.ReportDiagnostic(diagnostic);
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;
	}

	protected CheckResult CheckPropertyChangedMethodSignature(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol,
		IFieldSymbol fieldSymbol,
		INamedTypeSymbol attributeSymbol,
		string[] parameterTypes)
	{
		AttributeData attributeData = fieldSymbol.GetAttributeData(attributeSymbol);
		string? propertyChangedMethodName = attributeData.GetOnPropertyChangedMethod();

		if (propertyChangedMethodName == null)
		{
			return CheckResult.Valid;
		}

		IMethodSymbol? propertyChangedMethod = classSymbol
			.GetMembers()
			.OfType<IMethodSymbol>()
			.FirstOrDefault(x => x.Name == propertyChangedMethodName);

		if (propertyChangedMethod == null)
		{
			AddDiagnostic(Diagnostics.MissingPropertyChangedMethod);
			return CheckResult.Invalid;
		}

		if (!propertyChangedMethod.IsStatic)
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		if (propertyChangedMethod.ReturnType.SpecialType != SpecialType.System_Void)
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		ImmutableArray<IParameterSymbol> parameters = propertyChangedMethod.Parameters;

		if (!parameters.Select(x => x.Type.ToDisplayString()).SequenceEqual(parameterTypes))
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;

		void AddDiagnostic(DiagnosticDescriptor? diagnosticDescriptor = null)
		{
			diagnosticDescriptor ??= Diagnostics.IncorrectPropertyChangedMethodSignature;

			Diagnostic diagnostic = Diagnostic.Create(
				diagnosticDescriptor,
				fieldSymbol.Locations.FirstOrDefault() ?? Location.None,
				classSymbol.Name,
				propertyChangedMethod);

			context.ReportDiagnostic(diagnostic);
		}
	}

	protected CheckResult CheckCoerceValueMethodSignature(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol,
		IFieldSymbol fieldSymbol,
		INamedTypeSymbol attributeSymbol,
		string[] parameterTypes)
	{
		AttributeData attributeData = fieldSymbol.GetAttributeData(attributeSymbol);
		string? coerceValueMethodName = attributeData.GetOnCoerceValueMethod();

		if (coerceValueMethodName == null)
		{
			return CheckResult.Valid;
		}

		IMethodSymbol? coerceValueMethod = classSymbol
			.GetMembers()
			.OfType<IMethodSymbol>()
			.FirstOrDefault(x => x.Name == coerceValueMethodName);

		if (coerceValueMethod == null)
		{
			AddDiagnostic(Diagnostics.MissingCoerceValueMethod);
			return CheckResult.Invalid;
		}

		if (!coerceValueMethod.IsStatic)
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		if (coerceValueMethod.ReturnType.SpecialType != SpecialType.System_Object)
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		ImmutableArray<IParameterSymbol> parameters = coerceValueMethod.Parameters;

		if (!parameters.Select(x => x.Type.ToDisplayString()).SequenceEqual(parameterTypes))
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;

		void AddDiagnostic(DiagnosticDescriptor? diagnosticDescriptor = null)
		{
			diagnosticDescriptor ??= Diagnostics.IncorrectCoerceValueMethodSignature;

			Diagnostic diagnostic = Diagnostic.Create(
				diagnosticDescriptor,
				fieldSymbol.Locations.FirstOrDefault() ?? Location.None,
				classSymbol.Name,
				coerceValueMethodName);

			context.ReportDiagnostic(diagnostic);
		}
	}

	protected CheckResult CheckDefaultValueField(
		SourceProductionContext context,
		INamedTypeSymbol classSymbol,
		IFieldSymbol fieldSymbol,
		INamedTypeSymbol attributeSymbol)
	{
		AttributeData attributeData = fieldSymbol.GetAttributeData(attributeSymbol);
		string? defaultValueFieldName = attributeData.GetDefaultValueField();

		if (defaultValueFieldName == null)
		{
			return CheckResult.Valid;
		}

		IFieldSymbol? defaultValueField = classSymbol
			.GetMembers()
			.OfType<IFieldSymbol>()
			.FirstOrDefault(x => x.Name == defaultValueFieldName);

		TypedConstant propertyType = attributeData.ConstructorArguments.SingleOrDefault();

		if (defaultValueField == null)
		{
			AddDiagnostic(Diagnostics.MissingDefaultValueField);
			return CheckResult.Invalid;
		}

		if (!defaultValueField.IsStatic)
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		if (!defaultValueField.Type.Equals(propertyType.Value as INamedTypeSymbol, SymbolEqualityComparer.Default))
		{
			AddDiagnostic();
			return CheckResult.Invalid;
		}

		return CheckResult.Valid;

		void AddDiagnostic(DiagnosticDescriptor? diagnosticDescriptor = null)
		{
			diagnosticDescriptor ??= Diagnostics.IncorrectDefaultValueFieldDefinition;

			Diagnostic diagnostic = Diagnostic.Create(
				diagnosticDescriptor,
				fieldSymbol.Locations.FirstOrDefault() ?? Location.None,
				defaultValueFieldName,
				propertyType.Value);

			context.ReportDiagnostic(diagnostic);
		}
	}
}